0equalc
1equal√¥
2equal 
3equalt
4equal·∫•
5equalm
6equal,
7equalb
8equal·ªë
9equaln
10equalg
11equala
12equalq
13equalu
14equal·∫£
15equalh
16equal·ªã
17equal∆°
18equal‚Ä¶
19equal·ªØ
20equal√¨
21equalr
22equalo
23equal.
24equalƒë
25equal√£
26equal·ªü
27equal√™
28equalv
29equal√π
30equale
31equal·ªô
32equal·ªõ
33equali
34equal·ªï
35equal·ªß
36equal·∫ª
37equal·ªá
38equald
39equal‚Äù
40equal1
41equal5
42equal8
43equal‚Ä≥
44equaly
45equalk
46equal·ªÉ
47equal·ªÅ
48equall
49equal√†
50equal·∫ø
51equal·ª•
52equal√°
53equal·∫°
54equal∆∞
55equal·ª£
56equal√∫
57equalp
58equal·ª°
59equal≈©
60equal√≥
61equals
62equal·ªç
63equal√≠
64equal√©
65equal·∫Ω
66equal·∫Ø
67equal·∫∑
68equal√¢
69equal·ªù
70equal·ª±
71equal·ªì
72equalx
73equal·ª≠
74equal·∫π
75equal√≤
76equal2
77equal:
78equal‚Äú
79equal·ªÖ
80equal·ª©
81equalƒÉ
82equal·ªâ
83equal·∫≥
84equal·ªè
85equal·∫ß
86equal·∫´
87equal√Ω
88equal‚Äì
89equal	
90equal·ªó
91equal?
92equal·∫©
93equal·∫≠
94equal!
95equal4
96equal·ª´
97equal√µ
98equal3
99equalƒ©
100equal·∫µ
101equal·ª≥
102equal·∫±
103equal√®
104equal‚Äã
105equal6
106equal9
107equal7
108equalz
109equal·ª∑
110equal¬†
111equal0
112equal-
113equal·ªπ
114equalw
115equal;
116equal√∞
117equal¬≠
118equalj
119equalf
120equalüòú
121equal·ªµ
122equalÔªø
123equalÃ£
124equalÃÄ
125equalÃÅ
126equalÃÉ
127equalÃâ
128equal¬´
129equal¬ª
130equal‚Äï
131equal/
132equal‚òπ
133equal¬∑
134equal"
135equal‚Äô
136equal‚Äò
137equal‚Ä≤
138equalÔøΩ
139equal<PAD>
140equal<EOS>
141equal<GO>
//////////////////////////////////////////////////////////////////////////////////
from constants_tones import ALL_SINGLE_TONES, NUM_TONES, DOUBLE_CLICK_VOWELS, COMMA_MARK_VOWELS, \
    NUM_CM, NUM_DC, LIST_D_TONES, LIST_T_TONES, LiST_S_TONES, \
    MAP_VOWEL_TYPE


class ToneUtils:
    @classmethod
    def check_vowel_type(cls, word):
        word = str(word).strip()
        for index in range(len(word) - 2):
            if word[index:index + 3] in LIST_T_TONES:
                return 3
        for index in range(len(word) - 1):
            if word[index:index + 2] in LIST_D_TONES:
                return 2
        for index in range(len(word)):
            if word[index] in LiST_S_TONES:
                return 1

        return -1

    @classmethod
    def find_tone(cls, word, vowel_type):
        for index in range(len(word) - vowel_type + 1):
            # found a vowel
            for tone_vowel in MAP_VOWEL_TYPE[vowel_type]:
                # it is a toned vowel
                word_vowel = word[index:index + vowel_type]
                if word_vowel in tone_vowel:
                    return tone_vowel.index(word_vowel) % NUM_TONES, word.index(word_vowel)
        # unmarked
        return -1, None

    @classmethod
    def change_tone(cls, word, vowel_type, tone_type, tone_index):
        if tone_type > NUM_TONES:
            return word
        word = str(word).strip()
        word_vowel = word[tone_index:tone_index + vowel_type]
        replace_vowel = word_vowel
        for tone_vowel in MAP_VOWEL_TYPE[vowel_type]:
            if word_vowel in tone_vowel:
                replace_vowel = tone_vowel[tone_vowel.index(word_vowel)
                                           - (tone_vowel.index(word_vowel) % NUM_TONES)
                                           + tone_type]
                break
        return word.replace(word_vowel, replace_vowel)

    @classmethod
    def find_double_click(cls, word):
        for letter in word:
            for dc_vowel in DOUBLE_CLICK_VOWELS:
                if letter in dc_vowel[1:]:
                    return dc_vowel.index(letter) % NUM_DC, word.index(letter)
        return -1, None

    @classmethod
    def find_comma_mark(cls, word):
        for letter in word:
            for cm_vowel in COMMA_MARK_VOWELS:
                if letter in cm_vowel[1:]:
                    return cm_vowel.index(letter) % NUM_CM, word.index(letter)

        return -1, None

    def check_word_attr(self, word):
        vowel_type = self.check_vowel_type(word)
        tone, tone_index = self.find_tone(word=word,
                                          vowel_type=vowel_type)
        un_tone_word = self.change_tone(word=word,
                                        vowel_type=vowel_type,
                                        tone_index=tone_index,
                                        tone_type=0)
        db_click, dbc_index = self.find_double_click(un_tone_word)
        com_mark, cm_index = self.find_comma_mark(un_tone_word)

        attr = dict()
        attr["tone"] = (tone, tone_index)
        attr["double click"] = (db_click, dbc_index)
        attr["comma mark"] = (com_mark, cm_index)
        attr["vowel type"] = (vowel_type, tone_index)
        return attr, un_tone_word
#
/////////////////////////////////////////////////////////////////
"""
6 tones in total, including "unmarked" mark
ngang = 0, huy·ªÅn = 1, s·∫Øc = 2, h·ªèi = 3, ng√£ = 4, n·∫∑ng = 5
"""
NUM_TONES = 6
"""
Nguyen am ba trong tieng viet co dau danh o phia sau
"""
TONE_T_IEU = "ieu i√®u i√©u i·∫ªu i·∫Ωu i·∫πu i√™u i·ªÅu i·∫øu i·ªÉu i·ªÖu i·ªáu".split()
TONE_T_YEU = "yeu y√®u y√©u y·∫ªu y·∫Ωu y·∫πu y√™u y·ªÅu y·∫øu y·ªÉu y·ªÖu y·ªáu".split()
TONE_T_OAI = "oai o√†i o√°i o·∫£i o√£i o·∫°i".split()
TONE_T_OAO = "oao o√†o o√°o o·∫£o o√£o o·∫°o".split()
TONE_T_OEO = "oeo o√®o o√©o o·∫ªo o·∫Ωo o·∫πo".split()
TONE_T_UAY = "uay u√†y u√°y u·∫£y u√£y u·∫°y u√¢y u·∫ßy u·∫•y u·∫©y u·∫´y u·∫≠y".split()
TONE_T_UOI = "uoi u√≤i u√≥i u·ªèi u√µi u·ªçi u√¥i u·ªìi u·ªëi u·ªïi u·ªói u·ªôi ∆∞∆°i ∆∞·ªùi ∆∞·ªõi ∆∞·ªüi ∆∞·ª°i ∆∞·ª£i".split()
TONE_T_UOU = "uou u√≤u u√≥u u·ªèu u√µu u·ªçu ∆∞∆°u ∆∞·ªùu ∆∞·ªõu ∆∞·ªüu ∆∞·ª°u ∆∞·ª£u".split()
TONE_T_UYA = "uya u·ª≥a u√Ωa u·ª∑a u·ªπa u·ªµa".split()
TONE_T_UYE = "uye uy√® uy√© uy·∫ª uy·∫Ω uy·∫π uy√™ uy·ªÅ uy·∫ø uy·ªÉ uy·ªÖ uy·ªá".split()
TONE_T_UYU = "uyu u·ª≥u u√Ωu u·ª∑u u·ªπu u·ªµu".split()

LIST_T_TONES = TONE_T_IEU \
               + TONE_T_YEU \
               + TONE_T_OAI \
               + TONE_T_OAI \
               + TONE_T_OAO \
               + TONE_T_OEO \
               + TONE_T_UAY \
               + TONE_T_UOI \
               + TONE_T_UOU \
               + TONE_T_UYA \
               + TONE_T_UYE \
               + TONE_T_UYU

ALL_TRIPLE_TONES = [TONE_T_IEU,
                    TONE_T_YEU,
                    TONE_T_OAI,
                    TONE_T_OAO,
                    TONE_T_OEO,
                    TONE_T_UAY,
                    TONE_T_UOI,
                    TONE_T_UOU,
                    TONE_T_UYA,
                    TONE_T_UYE,
                    TONE_T_UYU]

"""
Nguyen am doi trong tieng viet co dau danh o phia sau
"""
TONE_D_IE = "ie i√® i√© i·∫ª i·∫Ω i·∫π i√™ i·ªÅ i·∫ø i·ªÉ i·ªÖ i·ªá".split()
TONE_D_YE = "ye y√® y√© y·∫ª y·∫Ω y·∫π y√™ y·ªÅ y·∫ø y·ªÉ y·ªÖ y·ªá".split()
TONE_D_OA = "oa o√† o√° o·∫£ o√£ o·∫° oƒÉ o·∫± o·∫Ø o·∫≥ o·∫µ o·∫∑ o√¢ o·∫• o·∫ß o·∫© o·∫´ o·∫≠".split()
TONE_D_OE = "oe o√® o√© o·∫ª o·∫Ω o·∫π o√™ o·ªÅ o·∫ø o·ªÉ o·ªÖ o·ªá".split()
TONE_D_OO = "oo o√≤ o√≥ o·ªè o√µ o·ªç".split()
TONE_D_UA = "ua u√† u√° u·∫£ u√£ u·∫° u√¢ u·∫ß u·∫• u·∫© u·∫´ u·∫≠".split()
TONE_D_UE = "ue u√® u√© u·∫ª u·∫Ω u·∫π u√™ u·ªÅ u·∫ø u·ªÉ u·ªÖ u·ªá".split()
TONE_D_UO = "uo u√≤ u√≥ u·ªè u√µ u·ªç u√¥ u·ªì u·ªë u·ªï u·ªó u·ªô u∆° u·ªù u·ªõ u·ªü u·ª° u·ª£ ∆∞∆° ∆∞·ªù ∆∞·ªõ ∆∞·ªü ∆∞·ª° ∆∞·ª£".split()

LIST_D_TONES = TONE_D_IE \
               + TONE_D_YE \
               + TONE_D_OA \
               + TONE_D_OE \
               + TONE_D_OO \
               + TONE_D_UA \
               + TONE_D_UE \
               + TONE_D_UO
ALL_DOUBLE_TONES = [TONE_D_IE,
                    TONE_D_YE,
                    TONE_D_OA,
                    TONE_D_OE,
                    TONE_D_OO,
                    TONE_D_UA,
                    TONE_D_UE,
                    TONE_D_UO]

"""
Nguyen am don trong tieng viet 
"""
TONE_S_A = "a √† √° ·∫£ √£ ·∫° ƒÉ ·∫± ·∫Ø ·∫≥ ·∫µ ·∫∑ √¢ ·∫ß ·∫• ·∫© ·∫´ ·∫≠".split()
TONE_S_E = "e √® √© ·∫ª ·∫Ω ·∫π √™ ·ªÅ ·∫ø ·ªÉ ·ªÖ ·ªá".split()
TONE_S_I = "i √¨ √≠ ·ªâ ƒ© ·ªã".split()
TONE_S_O = "o √≤ √≥ ·ªè √µ ·ªç √¥ ·ªì ·ªë ·ªï ·ªó ·ªô ∆° ·ªù ·ªõ ·ªü ·ª° ·ª£".split()
TONE_S_U = "u √π √∫ ·ªß ≈© ·ª• ∆∞ ·ª´ ·ª© ·ª≠ ·ªØ ·ª±".split()
TONE_S_Y = "y ·ª≥ √Ω ·ª∑ ·ªπ ·ªµ".split()

LiST_S_TONES = TONE_S_A \
               + TONE_S_E \
               + TONE_S_I \
               + TONE_S_O \
               + TONE_S_U \
               + TONE_S_Y

ALL_SINGLE_TONES = [TONE_S_A,
                    TONE_S_E,
                    TONE_S_I,
                    TONE_S_O,
                    TONE_S_U,
                    TONE_S_Y]

"""
cac tu click phim hai lan
"""
DC_A = "a √¢".split()
DC_E = "e √™".split()
DC_O = "o √¥".split()

NUM_DC = 2
DOUBLE_CLICK_VOWELS = [DC_A,
                       DC_E,
                       DC_O]

"""
cac tu su dung phim "w"
"""
CM_A = "a ƒÉ".split()
CM_O = "o ∆°".split()
CM_U = "u ∆∞".split()

NUM_CM = 2
COMMA_MARK_VOWELS = [CM_A,
                     CM_O,
                     CM_U]

MAP_ERROR_TONE_KEYBOARD = {
    0: "",
    1: "f",
    2: "s",
    3: "r",
    4: "x",
    5: "j"
}

MAP_VOWEL_TYPE = {
    1: ALL_SINGLE_TONES,
    2: ALL_DOUBLE_TONES,
    3: ALL_TRIPLE_TONES
}
///////////////////////////////////
from constants_tones import ALL_SINGLE_TONES, NUM_TONES, DOUBLE_CLICK_VOWELS, NUM_DC, \
    COMMA_MARK_VOWELS, NUM_CM, MAP_ERROR_TONE_KEYBOARD
import numpy as np
from utils.tone import ToneUtils


class GenErrorToneSentence:
    def __init__(self):
        """
        "0": error tone
        "1": error double click
        "2": error comma mark
        """
        self.map_rate_error = {
            "0": 0.33,
            "1": 0.66,
            "2": 1.0
        }
        self.tone_utils = ToneUtils()

    def gen_tone_error(self, word, un_tone_word, word_attr):
        tone, tone_index = word_attr["tone"]
        vowel, vowel_index = word_attr["vowel type"]
        random_tone_error = np.random.uniform(0, 1, 1)
        if random_tone_error <= 0.5:
            new_tone = np.random.randint(0, 6, 1)[0]
            while new_tone == tone:
                new_tone = np.random.randint(0, 6, 1)[0]
            new_word = self.tone_utils.change_tone(word=word,
                                                   tone_type=new_tone,
                                                   tone_index=tone_index,
                                                   vowel_type=vowel)
        else:
            append_letter = MAP_ERROR_TONE_KEYBOARD[tone]
            new_word = un_tone_word + append_letter

        return new_word

    def gen_double_click_error(self, word, un_tone_word, word_attr):
        tone, tone_index = word_attr["tone"]
        db_click, dbc_index = word_attr["double click"]
        vowel, vowel_index = word_attr["vowel type"]
        word_letters = list(un_tone_word)
        append_letter = ""
        for dbc_vowel in DOUBLE_CLICK_VOWELS:
            if word_letters[dbc_index] in dbc_vowel:
                word_letters[dbc_index] = dbc_vowel[0]
                append_letter = dbc_vowel[0]

        random_dbc_error = np.random.uniform(0, 1, 1)
        word_letters[dbc_index] = append_letter
        if random_dbc_error <= 0.5:
            new_word = self.tone_utils.change_tone(word="".join(word_letters),
                                                   tone_type=tone,
                                                   tone_index=tone_index,
                                                   vowel_type=vowel) \
                       + str(append_letter)
        else:
            new_word = self.tone_utils.change_tone(word="".join(word_letters),
                                                   tone_type=tone,
                                                   tone_index=tone_index,
                                                   vowel_type=vowel)
            word_letters = list(new_word)
            word_letters.insert(dbc_index + 1, append_letter)
            new_word = "".join(word_letters)
        return new_word

    def gen_comma_mark_error(self, word, un_tone_word, word_attr):
        tone, tone_index = word_attr["tone"]
        cm_click, cm_index = word_attr["comma mark"]
        vowel, vowel_index = word_attr["vowel type"]
        if "∆∞∆°" in word:


        else:
            word_letters = list(un_tone_word)
            for vowel in COMMA_MARK_VOWELS:
                if word_letters[cm_index] in vowel:
                    word_letters[cm_index] = vowel[0]
            new_word = self.tone_utils.change_tone("".join(word_letters), tone) + "w"

        return new_word

    def gen_typing_error_word(self, word, un_tone_word, word_attr, threshold):
        random_error_choice = np.random.uniform(0, 1, 1)
        if random_error_choice < threshold:
            return word
        else:
            self.update_map_rate_error(word_attr=word_attr)
            if int(sum(self.map_rate_error.values())) == -3:
                return word
            error_type_choice = np.random.uniform(0, 1, 1)
            if error_type_choice <= self.map_rate_error["0"]:
                new_word = self.gen_tone_error(word=word,
                                               un_tone_word=un_tone_word,
                                               word_attr=word_attr)
            elif self.map_rate_error["0"] < error_type_choice <= self.map_rate_error["1"]:
                new_word = self.gen_double_click_error(word=word,
                                                       un_tone_word=un_tone_word,
                                                       word_attr=word_attr)
            else:
                new_word = self.gen_comma_mark_error(word=word,
                                                     un_tone_word=un_tone_word,
                                                     word_attr=word_attr)
        return new_word

    def update_map_rate_error(self, word_attr):
        rate_error = list()
        rate_error.append(word_attr["tone"][0] > 0)
        rate_error.append(word_attr["db click"][0] > 0)
        rate_error.append(word_attr["comma mark"][0] > 0)
        error_total = sum(rate_error)
        if int(error_total) == 0:
            self.map_rate_error = {
                "0": -1.0,
                "1": -1.0,
                "2": -1.0
            }
            return
        else:
            unit_rate = round(float(1 / error_total), 2)

        init_rate = 0
        for index in range(0, 3):
            if rate_error[index]:
                init_rate = init_rate + unit_rate
                self.map_rate_error[str(index)] = init_rate
            else:
                self.map_rate_error[str(index)] = init_rate
        self.map_rate_error["2"] = 1.0

    def gen_typing_error_sentence(self, sentence="", threshold=0.9):
        sentence = sentence.strip()
        if sentence == "":
            return sentence
        sentence_words = sentence.split()
        error_sentences = list()
        for i in range(100):
            error_sentence = []
            for word in sentence_words:
                word_attr, un_tone_word = self.check_word_attr(word=word)
                new_word = self.gen_typing_error_word(word=word,
                                                      un_tone_word=un_tone_word,
                                                      word_attr=word_attr,
                                                      threshold=threshold)
                error_sentence.append(new_word)
            error_sentences.append(" ".join(error_sentence))
        error_sentences = list(set(error_sentences))
        for i in error_sentences:
            print(i)


if __name__ == "__main__":
    text = "y·∫øn"
    gen = GenErrorToneSentence()
    word_attr_, un_tone_word_ = gen.tone_utils.check_word_attr(word=text)
    for i in range(10):
        print(gen.gen_double_click_error(word=text,
                                   un_tone_word=un_tone_word_,
                                   word_attr=word_attr_))
